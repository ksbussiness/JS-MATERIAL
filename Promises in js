

..> A Promise is basically an object which represents the completion (or failure) of an asynchronous operation along with its result. 


The promise constructor takes only one argument which is a callback function
The callback function takes two arguments, resolve and reject
Perform operations inside the callback function and if everything went well then call resolve.
If desired operations do not go well then call reject.

..> Promise method is invoked when a promise is either resolved or rejected.

...>

let promise = new Promise(function (resolve, reject) {
    resolve('Geeks For Geeks');
})

promise
    .then(function (successMessage) {
        //success handler function is invoked 
        console.log(successMessage);
    })
    .catch(function (errorMessage) {
        console.log(errorMessage);
    }); 


PROMISES in JavaScript:

..> A promise is an object that keep track about whether a certain event has happened already or not.

..>Promises are used to handle asynchronous operations in javascript.
..> They are easy to manage when dealing with multiple asynchronous operations where callbacks can create callback hell leading to unmanageable code.

..>


A promise has 3 states:

pending:
resolve:
reject:

..> in order to create the new promise we use the new keyword:

..> The methods promise.then(), promise.catch(), and promise.finally() are used to associate further action with a promise that become settled.

..> 




Promises are used to handle the Asynchronous in the javascript 

..>    fetch returns the promise


const GITHUB_API="https://api.github.com"


const user=fetch(GITHUB_API); // it will return the promise

console.log(user) // here we get teh promise has the pending state
// because here, fetch will call the api and next, here, it takes the time to fetch teh api, and next , when i print here, it will showa has the pending here, it is not resolved, and js not waits until the promise , to resloved here, 


//  when ever you have the multiple promises them use the chaining of the promises, instead of  writing teh individula promises



// Promise Chning 

const cart=["shoes","pants","kurtas"];

const promise=createOrder(cart);

promise.then(function (orderId){
    console.log(orderId);
    return orderId;
})
.then(function(orderId){
    return proceedToPayment(orderId);
})
.then(function(paymentInfo){
    console.log(paymentInfo)
})
.catch(function (err){
    console.log(err.message,"jjj");
})
.then(function(orderId){
    console.log("Nomatter whct i will be called here")
    
})

function createOrder(cart){
    const pr = new Promise(function(resolve,reject){
        
        if(!validateCart(cart)){
            const err=new Error("cart is not valid")
            reject(err);
        }
        
        const orderId="1234";
        if(orderId){
            setTimeout( function(){
                
             resolve(orderId)},5000)
          
        }
    });
    return pr;
}


function proceedToPayment(orderId){
    return new Promise(function (resolve,reject){
        resolve("Payment Succesfull");
        
        
    })
}

function validateCart(cart){
    return true;
   //return false
}




//                           PROMISE.ALL()


//Here in this .all() it will take the iterables in side it has the arguments here

// Here .all() it used to makke the 3 paralle api calls here, 

// Promise.all([p1,p2,p3])

// Here it will wait for all of the 3 api calls to finish here , after that only it will be give the results.


// It wil give the array of teh outputs here.

// promise.all , here if any one of the 3 promises  encounter with th error then it will be give error only here, it will not wait for the others to execute her.

// here it wil give us the array of the objects here


//                              PROMISE.ALLSETTELED()

// ..> here it is also used to make the paralle api calls here

// / Promise.all([p1,p2,p3])

// Here it will wait for all of the 3 api calls to finish here , like wheather the promises are resloveed or rejected no matter here ,after that only it will be give the results.

// after all the promises are the setteled then it will give results 


//                                 PROMISE.RACE()
 
// ..> here it will be used make the paralle api calls but 

// ..> here if any of the promise is rejected first  then immediately it will give us the error message and. stops there because here it is the race between the all the promises here

// ..> here if any of the first promise is resolved then it will , give us the result back, has successfull here and it will stops the others, because here it only give us teh first promises only { whather it will be failed here ot resolved here  } do not matther here.



//                                   PROMISE.ANY()

..> here also it will be take the array of the promises has inputs here

..> here it will wait for any of the promises to resolve firt , which means here you need to wait for teh first successfully promises to be resolved here.

..> if all the promises here is failed then we get the Aggregated error here

...> 



..> When working with an array of promises in JavaScript, you typically handle them using either Promise.all, Promise.allSettled, Promise.any, or Promise.race
..> 


# PROMISE.ALL:

Promise.all
========================>

Purpose: Wait for all promises to resolve, or reject if any one of them rejects.

Use case: When you need all the promises to be successful before proceeding



const p = [
    Promise.resolve(10),
    Promise.resolve(20),
    Promise.resolve(30)
];

Promise.all(p)
    .then(results => {
        console.log('All resolved:', results); // [10, 20, 30]
    })
    .catch(error => {
        console.error('At least one promise rejected:', error);
    });



EX: use for the Promise.All() in Js code:
-------------------------------------------------- .>
try {
    const [user, orders, cart] = await Promise.all([
        User.findById(userId),
        Order.find({ userId }),
        Cart.findOne({ userId }),
    ]);
    res.status(200).json({ user, orders, cart });
} catch (err) {
    res.status(500).json({ message: "Something failed", error: err });
}

If queries are dependent on each other, go with await one by one.

If they are independent, prefer Promise.all for better performance.


# Promise.allSettled
============================>

Purpose: Wait for all promises to settle (resolve or reject) and get their results in an array of objects with status and value/reason.

Use case: When you want the result of every promise regardless of whether it resolved or rejected.



const p = [
    Promise.resolve(10),
    Promise.reject('Error occurred'),
    Promise.resolve(30)
];

Promise.allSettled(p)
    .then(results => {
        console.log('Results:', results);
        // [
        //   { status: 'fulfilled', value: 10 },
        //   { status: 'rejected', reason: 'Error occurred' },
        //   { status: 'fulfilled', value: 30 }
        // ]
    });



# Promise.any
=========================>

Purpose: Wait for the first promise to resolve and return its result. If all promises reject, it throws an AggregateError.

Use case: When you need only one promise to succeed.


const p = [
    Promise.reject('Error 1'),
    Promise.resolve(20),
    Promise.resolve(30)
];

Promise.any(p)
    .then(result => {
        console.log('First resolved:', result); // 20
    })
    .catch(error => {
        console.error('All promises rejected:', error);
    });


# Promise.race
================================>

Purpose:  Wait for the first promise to settle (resolve or reject) and return its result or error.

Use case:  When you only care about the first promise that settles

const promises = [
     new Promise(resolve => setTimeout(() => resolve(10), 100)),
    new Promise((reject) => setTimeout(() => reject('Error'), 50)),
    Promise.resolve(30)
];

Promise.race(promises)
    .then(result => {
        console.log('First settled:', result); // 'Error' (rejected after 50ms)
    })
    .catch(error => {
        console.error('First settled error:', error);
    });



