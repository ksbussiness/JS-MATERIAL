
Therory concepts about the promise:
-------------------------------------- >

simple : A Promise represents a value that, is not available yet, but will be available in the future or may fail

..> A Promise is basically an object which represents the completion (or failure) of an asynchronous operation along with its result. OR
..> A promise is an object that keep track about whether a certain event has happened already or not.
..> Promise constructor takes only one argument which is a callback function.
..> The callback function takes two arguments, resolve and reject.
..> And the promise perform operation's inside the callback function and if everything went well then call resolve, if an error happens then call reject.
..> Promise method is invoked when a promise is either resolved or rejected.
..> Promises are used to handle asynchronous operations in javascript.
..> They are easy to manage when dealing with multiple asynchronous operations where callbacks can create callback hell leading to unmanageable code.

synatx of te promise :
----------------------------- >
new Promise( callBcFun(resolve,reject) )
note: In order to create the new promise we use the new keyword.

ex:
------- >
let pp = new Promise(function (resolve, reject) {
    resolve('Ok everything is good');
})
console.log(pp)  // Promise { 'Ok everything is good' }


ex: Using a Promise (then, catch, finally)

let pp= new Promise( function(resolve, reject) {
    resolve("Ok everything is good")
})

pp.then(result =>{
    console.log(result)
}).catch(error=>{
    console.log(error)
}).finally(d=>{
    console.log("done")
}) 

Ok everything is good
done

Use cases of the promise :
------------------------------- >

# API calls >> Fetching data from a server and Waiting for a response.
# Timers and delays >> Waiting for some time and Retry mechanisms.
# Database operations >> Querying data and Saving records.
# Multiple async operations >> Run tasks in parallel, Run tasks in sequence and Wait until all tasks finished.
# Prevents callback hell >> Cleaner and more maintainable code.
# 

Cons of the promise :
-------------------------------- >

# No cancellation (by default) >> Once started, a promise cannot be stopped.
# Missing a .catch() can cause silent failures.
# Harder debugging

States in the promise :
------------------------- >
..> A promise has 3 states:
pending:
resolve:
reject:

..> The methods promise.then(), promise.catch(), and promise.finally() are used to associate further action with a promise that become settled.
..> Fetch returns the promise.

Example Explanation of an Promise:
------------------------------------------ >

const GIT_HUB_API="https://api.github.com"
const user=fetch(GITHUB_API); // it will return the promise


console.log(user)  // Promise { <pending> } and after some time it will throw error becasue here it is not handled
// here we get the promise has the pending state
// because here, fetch will call the api and next, here, it takes the time to fetch the api data.
// and next , when i print here, it will show has the pending here,becasue it is not resolved, and js not waits until the promise to get resloved.



Promises Chaning In Js:
--------------------------- >
..>   when ever you have the multiple promises them use the chaining of the promises, instead of  writing the individula promises.



// Promise Chaning 

const cart=["shoes","pants","kurtas"];

const promise=createOrder(cart);

promise.then(function (orderId){
    console.log(orderId);
    return orderId;
})
.then(function(orderId){
    return proceedToPayment(orderId);
})
.then(function(paymentInfo){
    console.log(paymentInfo)
})
.catch(function (err){
    console.log(err.message,"jjj");
})
.then(function(orderId){
    console.log("Nomatter whct i will be called here")
    
})

function createOrder(cart){
    const pr = new Promise(function(resolve,reject){
        
        if(!validateCart(cart)){
            const err=new Error("cart is not valid")
            reject(err);
        }
        
        const orderId="1234";
        if(orderId){
            setTimeout( function(){
             resolve(orderId)},5000)
        }
    });
    return pr;
}


function proceedToPayment(orderId){
    return new Promise(function (resolve,reject){
        resolve("Payment Succesfull");
    })
}

function validateCart(cart){
    return true;
   //return false
}

..> Promise chaining is the process of executing multiple asynchronous steps one after another, where:
    >> Each step waits for the previous one
    >> The output of one step becomes the input of the next

How chaining works conceptually :
...> A promise resolves with a value, That value is passed to the next .then()
   >> If the next .then() returns:
   >> a normal value → it becomes the next resolved value
   >> a promise → the chain waits for it to resolve
  >>  The chain continues until the end
  >>  Each .then() always returns a new promise.

...> A .then() must return something if the next step depends on it.

Error handling in chaining :
-------------------------------- >
...> If any step fails:, The chain skips remaining .then(), Control jumps to .catch(), This is called error bubbling.
...> You don’t need error handling at every step — one catch at the end is enough.

Common use cases of Promise chaining:
---------------------------------------- >
# Sequential API calls: Call API A → use response to call API B
# 

## => Promise chaining vs parallel execution
   >> Chaining → steps depend on each other
   >> Parallel → steps are independent and run together

Common mistakes in Promise chaining:
..> Nesting .then() inside .then()
    Recreates callback hell
    Breaks linear flow
..> Missing .catch()
    Leads to unhandled promise rejections



@@@@@@@@@@  promise.all()  Promise.allSetteled()    Promise.race()   Promise.any()    @@@@@@@@: 

1. PROMISE.ALL() :
-------------------- >

Purpose: Wait for all promises to resolve, or reject if any one of them rejects.
Use case: When you need all the promises to be successful before proceeding.

Syntax:
..> Promise.all( ArrayOfPromises );

...> .all() it will take the iterables in side it has the arguments here.

ex: Promise.all([p1,p2,p3])
...> Here .all() it used to make the 3 paralle api calls here.
...> Here it will wait for all of the 3 api calls to finish here , after that only it will give results.
...> It wil give the array of the outputs here.
...> promise.all , here if any one of the 3 promises  encounter with th error then it will be give error only here, it will not wait for the others to execute here.
...>  here it wil give us the array of the objects 

const p = [
    Promise.resolve(10),
    Promise.resolve(20),
    Promise.resolve(30)
];

Promise.all(p)
    .then(results => {
        console.log('All resolved:', results); // [10, 20, 30]
    })
    .catch(error => {
        console.error('At least one promise rejected:', error);
    });



EX: use for the Promise.All() in Js code:
-------------------------------------------------- .>
try {
    const [user, orders, cart] = await Promise.all([
        User.findById(userId),
        Order.find({ userId }),
        Cart.findOne({ userId }),
    ]);
    res.status(200).json({ user, orders, cart });
} catch (err) {
    res.status(500).json({ message: "Something failed", error: err });
}

If queries are dependent on each other, go with await one by one.
If they are independent, prefer Promise.all for better performance.

                        

2. Promise.AllSetteled():
------------------------------>

    Purpose: Wait for all promises to settle (resolve or reject) and get their results in an array of objects with status and value/reason.
    Use case: When you want the result of every promise regardless of whether it resolved or rejected.
..> Here it is also used to make the paralle api calls here
..> Promise.allSetteled([p1,p2,p3])
..> Here it will wait for all of the 3 api calls to finish here,  wheather the promises are resloveed or rejected no matter , and after all promises done work then only it will be give the results.
..> After all the promises are the setteled then it will give results 

EX :
    const p=[
        Promise.resolve(10),
        Promise.reject("Got an Error"),
        Promise.resolve(30)
        ]
        
    Promise.allSettled(p).then((result)=>{
        console.log(result)
    }).catch( (error)=>{
        console.log(error)
    })

output:
[
  { status: 'fulfilled', value: 10 },
  { status: 'rejected', reason: 'Got an Error' },
  { status: 'fulfilled', value: 30 }
]

3. PROMISE.RACE() :
--------------------- >
Purpose:  Wait for the first promise to settle (resolve or reject) and return its result or error.
Use case:  When you only care about the first promise that settles.
..> here it will be used make the paralle api calls,
..> if any of the promise is rejected first then immediately it will give us the error message and stops there because here it is the race between the all the promises.
..> amd if any of the first promise is resolved then it will , give us the result back, has successfull here and it will stops the others, because here it only give us the first promises only 
{ whather it will be failed or resolved here  } do not matther here.


const promises = [
     new Promise(resolve => setTimeout(() => resolve(10), 100)),
    new Promise((reject) => setTimeout(() => reject('Error'), 50)),
    Promise.resolve(30)
];

Promise.race(promises)
    .then(result => {
        console.log('First settled:', result); // 'Error' (rejected after 50ms)
    })
    .catch(error => {
        console.error('First settled error:', error);
    });



# 4.PROMISE.ANY() :
----------------------- >
Among the given promises if any of the promises are resolved then it will be given has resolved promise has back.
Purpose: Wait for the first promise to resolve and return its result. If all promises reject, it throws an AggregateError.
Use case: When you need only one promise to succeed.
..> It will be take the array of the promises has inputs here,
..> here it will wait for any of the promises to resolve firt ,which means here you need to wait for the first successfully promises to be resolved here.
..> if all the promises are failed then we get the Aggregated error.


const p = [
    Promise.reject('Error 1'),
    Promise.resolve(20),
    Promise.resolve(30)
];

Promise.any(p)
    .then(result => {
        console.log('First resolved:', result); // 20
    })
    .catch(error => {
        console.error('All promises rejected:', error);
    });


NOTE : When working with an array of promises in JavaScript, you typically handle them using either Promise.all, Promise.allSettled, Promise.any, or Promise.race
 





